<!DOCTYPE html>
<html lang="en-US">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" crossorigin="anonymous">


  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="http://localhost:1313/images/favicon.ico" />
<title>[One Paper Later] On-demand Container Loading in AWS Lambda | Aman Goyal</title>
<meta name="title" content="[One Paper Later] On-demand Container Loading in AWS Lambda" />
<meta name="description" content="This paper discusses how AWS rearchitected AWS Lambda to support container images up to 10 GiB, compared to the original 250 MiB ZIP-based functions." />
<meta name="keywords" content="AWS,Lambda,Serverless,Container,One Page Later Pod," />


<meta property="og:title" content="[One Paper Later] On-demand Container Loading in AWS Lambda" />
<meta property="og:description" content="This paper discusses how AWS rearchitected AWS Lambda to support container images up to 10 GiB, compared to the original 250 MiB ZIP-based functions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/one-paper-later-on-demand-container-loading-in-aws-lambda/" /><meta property="og:image" content="http://localhost:1313/images/on_demand_container_loading_on_aws.png" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2025-04-07T00:00:00+00:00" />
<meta property="article:modified_time" content="2025-04-07T00:00:00+00:00" /><meta property="og:site_name" content="Aman Goyal" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/images/on_demand_container_loading_on_aws.png" /><meta name="twitter:title" content="[One Paper Later] On-demand Container Loading in AWS Lambda"/>
<meta name="twitter:description" content="This paper discusses how AWS rearchitected AWS Lambda to support container images up to 10 GiB, compared to the original 250 MiB ZIP-based functions."/>



<meta itemprop="name" content="[One Paper Later] On-demand Container Loading in AWS Lambda">
<meta itemprop="description" content="This paper discusses how AWS rearchitected AWS Lambda to support container images up to 10 GiB, compared to the original 250 MiB ZIP-based functions."><meta itemprop="datePublished" content="2025-04-07T00:00:00+00:00" />
<meta itemprop="dateModified" content="2025-04-07T00:00:00+00:00" />
<meta itemprop="wordCount" content="745"><meta itemprop="image" content="http://localhost:1313/images/on_demand_container_loading_on_aws.png" />
<meta itemprop="keywords" content="AWS,Lambda,Serverless,Container,One Page Later Pod," />
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  :root {
      --width: 720px;
      --font-main: Verdana, sans-serif;
      --font-secondary: Verdana, sans-serif;
      --font-scale: 1em;
      --background-color: #fff;
      --heading-color: #222;
      --text-color: #444;
      --link-color: #3273dc;
      --visited-color:  #8b6fcb;
      --code-background-color: #f2f2f2;
      --code-color: #222;
      --blockquote-color: #222;
  }

  @media (prefers-color-scheme: dark) {
      :root {
          --background-color: #01242e;
          --heading-color: #eee;
          --text-color: #ddd;
          --link-color: #8cc2dd;
          --visited-color:  #8b6fcb;
          --code-background-color: #000;
          --code-color: #ddd;
          --blockquote-color: #ccc;
      }
  }

  body {
      font-family: var(--font-secondary);
      font-size: var(--font-scale);
      margin: auto;
      padding: 20px;
      max-width: var(--width);
      text-align: left;
      background-color: var(--background-color);
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.5;
      color: var(--text-color);
  }

  h1, h2, h3, h4, h5, h6 {
      font-family: var(--font-main);
      color: var(--heading-color);
  }

  a {
      color: var(--link-color);
      cursor: pointer;
      text-decoration: none;
  }

  a:hover {
      text-decoration: underline;
  }

  nav a {
      margin-right: 8px;
  }

  strong, b {
      color: var(--heading-color);
  }

  button {
      margin: 0;
      cursor: pointer;
  }

  time {
   	font-family: monospace;
    	font-style: normal;
    	font-size: 15px;
  }

  main {
      line-height: 1.6;
  }

  table {
      width: 100%;
  }

  hr {
      border: 0;
      border-top: 1px dashed;
  }

  img {
      max-width: 100%;
  }

  code {
      font-family: monospace;
      padding: 2px;
      background-color: var(--code-background-color);
      color: var(--code-color);
      border-radius: 3px;
  }

  blockquote {
      border-left: 1px solid #999;
      color: var(--code-color);
      padding-left: 20px;
      font-style: italic;
  }

  footer {
      padding: 25px 0;
      text-align: center;
  }

  .title:hover {
      text-decoration: none;
  }

  .title h1 {
      font-size: 1.5em;
  }

  .inline {
      width: auto !important;
  }

  .highlight, .code {
      padding: 1px 15px;
      background-color: var(--code-background-color);
      color: var(--code-color);
      border-radius: 3px;
      margin-block-start: 1em;
      margin-block-end: 1em;
      overflow-x: auto;
  }

   
  ul.blog-posts {
      list-style-type: none;
      padding: unset;
  }

  ul.blog-posts li {
      display: flex;
  }

  ul.blog-posts li span {
      flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
      color: var(--visited-color);
  }
</style>
</head>

<body>
  <header><header style="display: flex; justify-content: space-between; align-items: center; padding: 1rem 0rem;">
    <a href="/" class="title">
      <h2>Aman Goyal</h2>
    </a>
    <div>
      <a href="https://github.com/goyal-aman" target="_blank" style="margin: 0 10px; color: inherit;">
        <i class="fab fa-github fa-lg"></i>
      </a>
      <a href="https://www.linkedin.com/in/ln-amangoyal" target="_blank" style="margin: 0 10px; color: inherit;">
        <i class="fab fa-linkedin fa-lg"></i>
      </a>
      <a href="https://aman-goyal.medium.com/" target="_blank" style="margin: 0 10px; color: inherit;">
        <i class="fab fa-medium fa-lg"></i>
      </a>
      <a href="https://leetcode.com/sichern" target="_blank" style="margin: 0 10px; color: inherit;">
        <img src="/images/leetcode.svg" alt="LeetCode" style="height: 20px; vertical-align: middle;">
      </a>
      
        <a href="mailto:amangoyal8110@gmail.com" style="margin: 0 10px; color: inherit;" title="Email">
          <i class="fas fa-envelope fa-lg"></i>
        </a>
      
    </div>
  </header>
  <nav><a href="/">Home</a>


<a href="/blog">Blog</a>

</nav>
</header>
  <main>

<h1>[One Paper Later] On-demand Container Loading in AWS Lambda</h1>
<p>
  <i>
    <time datetime='2025-04-07'>
      07 Apr, 2025
    </time>
  </i>
</p>



  <img class="cover" src="/images/on_demand_container_loading_on_aws.png" alt="" />



<content>
  <hr>
<p>You can also listen to AI generated discussion</p>
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/episode/0IxfiKRMdnSIcDIMxChsd7?utm_source=generator" width="100%" height="152" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>
<hr>
<h1 id="overview">Overview</h1>
<p>AWS released this paper <a href="https://www.usenix.org/system/files/atc23-brooker.pdf">On-demand Container Loading in AWS Lambda</a> which discusses how they were able to scale their Lambda offering to support container images upto <strong>10 GiB</strong> from originail <strong>250 Mib</strong>.</p>
<p>Originally, users had to ZIP their code and upload it to S3 to run on Lambda. For each new invocation (especially after a cold start), AWS would spin up a new lightweight VM, pull the ZIP file, and execute it. This worked well because AWS’s global backbone network is fast and 250 MiB is relatively small, keeping cold-start times low (typically ~50ms).</p>
<p>With the move to supporting <strong>container images</strong> — and large ones, up to 10 GiB — two core challenges arose:</p>
<ul>
<li><strong>Network bandwidth</strong>: Servicing such large images could overwhelm network capacity.</li>
<li><strong>Cold start time</strong>: Pulling multi-GB images could drastically increase latency.</li>
</ul>
<p>Despite this, the core requirement remained: <strong>keep cold-start times near 50ms</strong>. This required significant engineering effort and innovation. For this they exploited three core properties of container images</p>
<ol>
<li><strong>Cacheability</strong>: The majority of workloads come from a small number of unique images.</li>
<li><strong>Commonality</strong>: Many popular images are based on common base layers (e.g., Alpine, Ubuntu).</li>
<li><strong>Sparsity</strong>: Most files inside container images are not needed at startup.</li>
</ol>
<h2 id="architecture">Architecture</h2>
<p>When a user invokes a Lambda function, the request eventually lands on a <strong>Lambda worker</strong>.</p>
<p><img src="/images/on_demand_container_loading_on_aws.png" alt="image.png"></p>
<p>Each Lambda worker can host multiple functions. A <strong>local agent</strong> process runs on the worker and communicates with the Firecracker VM via <strong>virtio</strong>, a standard virtual device interface. Inside the VM, this local agent appears as a <strong>block device</strong> (like a virtual hard disk).</p>
<h3 id="filesystem-preparation">Filesystem Preparation</h3>
<ul>
<li>When a container image is used for Lambda, at the time of Lambda function creation, its layers are flattened into a single <strong>ext4 filesystem</strong>.</li>
<li>This filesystem is split into <strong>512 KiB blocks</strong> in a <strong>deterministic</strong> way — meaning the same input always results in the same set of blocks.</li>
<li>Each block is <strong>individually encrypted</strong> using <strong>convergent encryption</strong>:
<ul>
<li>A <strong>cryptographic hash (AES-256)</strong> of the block is computed (with a salt).</li>
<li>This allows blocks from identical images (even across users) to be <strong>deduplicated</strong> and stored only once.</li>
</ul>
</li>
<li>A <strong>manifest</strong> stores these hash values and salts and is encrypted using <strong>user-level encryption keys</strong>.</li>
</ul>
<h3 id="storage-and-caching">Storage and Caching</h3>
<ul>
<li>Blocks are stored in <strong>S3</strong> and cached at:
<ul>
<li><strong>Availability Zone (AZ)</strong> level</li>
<li><strong>Local agent</strong> level (on the worker itself)</li>
</ul>
</li>
<li>These multi-layer caches are <strong>highly effective</strong>, serving <strong>~99.8% of requests</strong> from cache rather than S3.</li>
</ul>
<h3 id="startup-and-readwrite-behavior">Startup and Read/Write Behavior</h3>
<ul>
<li>When a function starts, it reads only the necessary blocks from the local-agent-backed block device.</li>
<li>Writes are handled via a <strong>copy-on-write</strong> mechanism:
<ul>
<li>A <strong>block overlay</strong> tracks page-level modifications.</li>
<li>A <strong>bitset</strong> marks which pages have changed.</li>
<li>Reads to modified pages are redirected to the overlay.</li>
</ul>
</li>
<li>This ensures the original cached blocks remain <strong>immutable and reusable</strong> across functions, improving cache hit rates and memory efficiency.</li>
</ul>
<h3 id="garbage-collection-gc">Garbage Collection (GC)</h3>
<p>A major challenge in deduplicated systems is <strong>safe and efficient garbage collection</strong>. Lambda avoids reference counting or centralized metadata to reduce complexity and risk. Instead, AWS introduced a <strong>root-based GC model</strong>:</p>
<ul>
<li>A <strong>root</strong> is a self-contained manifest and chunk namespace.</li>
<li>When a container image is processed, its manifest and chunks go into an <strong>active root</strong> (e.g., R1).</li>
<li>Periodically, a new root (R2) becomes active, and R1 is <strong>retired</strong>—serving reads only.</li>
<li>Active manifests and their referenced chunks in R1 are <strong>migrated</strong> to R2. Over time, all live data is moved to the new root.</li>
<li>Once safe, R1 is <strong>expired</strong>. In this state:
<ul>
<li>Reads are still allowed.</li>
<li>Any read triggers an <strong>alarm</strong> that pauses deletion and alerts operators, serving as a safety mechanism.</li>
</ul>
</li>
</ul>
<p>This process ensures:</p>
<ul>
<li>No accidental deletion of active data.</li>
<li>GC bugs have minimal blast radius.</li>
<li>The system can support <strong>multiple active roots</strong> to test or roll out GC updates gradually.</li>
</ul>
<p>While expired roots and chunk duplication increase storage costs slightly, the tradeoff is acceptable—most customer data is updated frequently, and not all data is migrated.</p>
<h3 id="conclusion">Conclusion</h3>
<p>AWS Lambda’s evolution from small ZIP files to massive 10GB container images is a masterclass in system design. By leveraging:</p>
<ul>
<li>Deterministic block generation and convergent encryption</li>
<li>Intelligent caching and copy-on-write overlays</li>
<li>A root-based, alarmed GC system</li>
</ul>
<p>AWS was able to maintain low cold start times while scaling Lambda to support modern containerized workflows. This architecture not only optimizes performance and resource usage but also preserves tenant isolation and security, all without disrupting the user experience.</p>
<hr>
<p>Source</p>
<ul>
<li><a href="https://www.usenix.org/system/files/atc23-brooker.pdf">On-demand Container Loading in AWS Lambda</a></li>
<li><a href="https://www.youtube.com/watch?v=Wden61jKWvs&amp;embeds_referring_euri=goyal-aman.github.io">Usenix Talk on On-demand Container Loading in AWS Lambda</a></li>
</ul>

</content>
<p>
  
  <a href="http://localhost:1313/blog/aws/">#AWS</a>
  
  <a href="http://localhost:1313/blog/lambda/">#Lambda</a>
  
  <a href="http://localhost:1313/blog/serverless/">#Serverless</a>
  
  <a href="http://localhost:1313/blog/container/">#Container</a>
  
  <a href="http://localhost:1313/blog/one-page-later-pod/">#One Page Later Pod</a>
  
</p>

  </main>
  <footer>
<footer style="text-align: center; padding: 1.5rem 0; font-size: 0.9rem; color: #777;">
  <div>
    <a href="https://github.com/goyal-aman" target="_blank" style="margin: 0 10px; color: inherit;">
      <i class="fab fa-github fa-lg"></i>
    </a>
    <a href="https://www.linkedin.com/in/ln-amangoyal" target="_blank" style="margin: 0 10px; color: inherit;">
      <i class="fab fa-linkedin fa-lg"></i>
    </a>
    <a href="https://aman-goyal.medium.com/" target="_blank" style="margin: 0 10px; color: inherit;">
      <i class="fab fa-medium fa-lg"></i>
    </a>
    <a href="https://leetcode.com/sichern" target="_blank" style="margin: 0 10px; color: inherit;">
      <img src="/images/leetcode.svg" alt="LeetCode" style="height: 20px; vertical-align: middle;">
    </a>
    
      <a href="mailto:amangoyal8110@gmail.com" style="margin: 0 10px; color: inherit;" title="Email">
        <i class="fas fa-envelope fa-lg"></i>
      </a>
    
  </div>

    <p>
      © 2025 Aman Goyal. Built with ❤️ using
      <a href="https://gohugo.io" target="_blank" style="color: inherit; text-decoration: underline;">Hugo</a>.
    </p>
  </footer>
  </footer>

    
</body>

</html>
