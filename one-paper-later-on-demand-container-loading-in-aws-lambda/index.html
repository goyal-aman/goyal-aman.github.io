<!doctype html><html lang=en-US><head><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.15.4/css/all.css crossorigin=anonymous><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://goyal-aman.github.io/images/favicon.png><title>[One Paper Later] On-demand Container Loading in AWS Lambda | Aman Goyal</title>
<meta name=title content="[One Paper Later] On-demand Container Loading in AWS Lambda"><meta name=description content="This paper discusses how AWS rearchitected AWS Lambda to support container images up to 10 GiB, compared to the original 250 MiB ZIP-based functions."><meta name=keywords content="AWS,Lambda,Serverless,Container,"><meta property="og:url" content="https://goyal-aman.github.io/one-paper-later-on-demand-container-loading-in-aws-lambda/"><meta property="og:site_name" content="Aman Goyal"><meta property="og:title" content="[One Paper Later] On-demand Container Loading in AWS Lambda"><meta property="og:description" content="This paper discusses how AWS rearchitected AWS Lambda to support container images up to 10 GiB, compared to the original 250 MiB ZIP-based functions."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-04-07T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-07T00:00:00+00:00"><meta property="article:tag" content="AWS"><meta property="article:tag" content="Lambda"><meta property="article:tag" content="Serverless"><meta property="article:tag" content="Container"><meta property="og:image" content="https://goyal-aman.github.io/images/share.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://goyal-aman.github.io/images/share.png"><meta name=twitter:title content="[One Paper Later] On-demand Container Loading in AWS Lambda"><meta name=twitter:description content="This paper discusses how AWS rearchitected AWS Lambda to support container images up to 10 GiB, compared to the original 250 MiB ZIP-based functions."><meta itemprop=name content="[One Paper Later] On-demand Container Loading in AWS Lambda"><meta itemprop=description content="This paper discusses how AWS rearchitected AWS Lambda to support container images up to 10 GiB, compared to the original 250 MiB ZIP-based functions."><meta itemprop=datePublished content="2025-04-07T00:00:00+00:00"><meta itemprop=dateModified content="2025-04-07T00:00:00+00:00"><meta itemprop=wordCount content="703"><meta itemprop=image content="https://goyal-aman.github.io/images/share.png"><meta itemprop=keywords content="AWS,Lambda,Serverless,Container"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fff;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--code-background-color:#f2f2f2;--code-color:#222;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#01242e;--heading-color:#eee;--text-color:#ddd;--link-color:#8cc2dd;--visited-color:#8b6fcb;--code-background-color:#000;--code-color:#ddd;--blockquote-color:#ccc}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;background-color:var(--code-background-color);color:var(--code-color);border-radius:3px}blockquote{border-left:1px solid #999;color:var(--code-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{padding:1px 15px;background-color:var(--code-background-color);color:var(--code-color);border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style><header style="display:flex;justify-content:space-between;align-items:center;padding:1rem 0"><a href=/ class=title><h2>Aman Goyal</h2></a><div><a href=https://github.com/goyal-aman target=_blank style="margin:0 10px;color:inherit"><i class="fab fa-github fa-lg"></i>
</a><a href=https://www.linkedin.com/in/ln-amangoyal target=_blank style="margin:0 10px;color:inherit"><i class="fab fa-linkedin fa-lg"></i>
</a><a href=https://aman-goyal.medium.com/ target=_blank style="margin:0 10px;color:inherit"><i class="fab fa-medium fa-lg"></i>
</a><a href=https://leetcode.com/sichern target=_blank style="margin:0 10px;color:inherit"><img src=/images/leetcode.svg alt=LeetCode style=height:20px;vertical-align:middle>
</a><a href=mailto:amangoyal8110@gmail.com style="margin:0 10px;color:inherit" title=Email><i class="fas fa-envelope fa-lg"></i></a></div></header><nav><a href=/>Home</a>
<a href=/blog>Blog</a></nav></head><body><header></header><main><h1>[One Paper Later] On-demand Container Loading in AWS Lambda</h1><p><i><time datetime=2025-04-07>07 Apr, 2025</time></i></p><img class=cover src=/images/on_demand_container_loading_on_aws.png alt>
<content><hr><p>AI Improved Version</p><p>This paper discusses how AWS rearchitected AWS Lambda to support container images up to <strong>10 GiB</strong>, compared to the original <strong>250 MiB</strong> ZIP-based functions.</p><p>Originally, users had to ZIP their code and upload it to S3 to run on Lambda. For each new invocation (especially after a cold start), AWS would spin up a new lightweight VM, pull the ZIP file, and execute it. This worked well because AWS’s global backbone network is fast and 250 MiB is relatively small, keeping cold-start times low (typically ~50ms).</p><p>With the move to supporting <strong>container images</strong> — and large ones, up to 10 GiB — two core challenges arose:</p><ul><li><strong>Network bandwidth</strong>: Servicing such large images could overwhelm network capacity.</li><li><strong>Cold start time</strong>: Pulling multi-GB images could drastically increase latency.</li></ul><p>Despite this, the core requirement remained: <strong>keep cold-start times near 50ms</strong>. This required significant engineering effort and innovation.</p><h2 id=key-container-image-characteristics-exploited>Key Container Image Characteristics Exploited</h2><ol><li><strong>Cacheability</strong>: The majority of workloads come from a small number of unique images.</li><li><strong>Commonality</strong>: Many popular images are based on common base layers (e.g., Alpine, Ubuntu).</li><li><strong>Sparsity</strong>: Most files inside container images are not needed at startup.</li></ol><h2 id=architecture>Architecture</h2><p>When a user invokes a Lambda function, the request eventually lands on a <strong>Lambda worker</strong>.</p><p><img src=/images/on_demand_container_loading_on_aws.png alt=image.png></p><p>Each Lambda worker can host multiple functions. A <strong>local agent</strong> process runs on the worker and communicates with the Firecracker VM via <strong>virtio</strong>, a standard virtual device interface. Inside the VM, this local agent appears as a <strong>block device</strong> (like a virtual hard disk).</p><h3 id=filesystem-preparation>Filesystem Preparation</h3><ul><li>When a container image is used for Lambda, its layers are flattened into a single <strong>ext4 filesystem</strong>.</li><li>This filesystem is split into <strong>512 KiB blocks</strong> in a <strong>deterministic</strong> way — meaning the same input always results in the same set of blocks.</li><li>Each block is <strong>individually encrypted</strong> using <strong>convergent encryption</strong>:<ul><li>A <strong>cryptographic hash (AES-256)</strong> of the block is computed (with a salt).</li><li>This allows blocks from identical images (even across users) to be <strong>deduplicated</strong> and stored only once.</li></ul></li><li>A <strong>manifest</strong> stores these hash values and salts and is encrypted using <strong>user-level encryption keys</strong>.</li></ul><h3 id=storage-and-caching>Storage and Caching</h3><ul><li>Blocks are stored in <strong>S3</strong> and cached at:<ul><li><strong>Availability Zone (AZ)</strong> level</li><li><strong>Local agent</strong> level (on the worker itself)</li></ul></li><li>These multi-layer caches are <strong>highly effective</strong>, serving <strong>~99.8% of requests</strong> from cache rather than S3.</li></ul><h3 id=startup-and-readwrite-behavior>Startup and Read/Write Behavior</h3><ul><li>When a function starts, it reads only the necessary blocks from the local-agent-backed block device.</li><li>Writes are handled via a <strong>copy-on-write</strong> mechanism:<ul><li>A <strong>block overlay</strong> tracks page-level modifications.</li><li>A <strong>bitset</strong> marks which pages have changed.</li><li>Reads to modified pages are redirected to the overlay.</li></ul></li><li>This ensures the original cached blocks remain <strong>immutable and reusable</strong> across functions, improving cache hit rates and memory efficiency.</li></ul><h3 id=garbage-collection-gc>Garbage Collection (GC)</h3><p>A major challenge in deduplicated systems is <strong>safe and efficient garbage collection</strong>. Lambda avoids reference counting or centralized metadata to reduce complexity and risk. Instead, AWS introduced a <strong>root-based GC model</strong>:</p><ul><li>A <strong>root</strong> is a self-contained manifest and chunk namespace.</li><li>When a container image is processed, its manifest and chunks go into an <strong>active root</strong> (e.g., R1).</li><li>Periodically, a new root (R2) becomes active, and R1 is <strong>retired</strong>—serving reads only.</li><li>Active manifests and their referenced chunks in R1 are <strong>migrated</strong> to R2. Over time, all live data is moved to the new root.</li><li>Once safe, R1 is <strong>expired</strong>. In this state:<ul><li>Reads are still allowed.</li><li>Any read triggers an <strong>alarm</strong> that pauses deletion and alerts operators, serving as a safety mechanism.</li></ul></li></ul><p>This process ensures:</p><ul><li>No accidental deletion of active data.</li><li>GC bugs have minimal blast radius.</li><li>The system can support <strong>multiple active roots</strong> to test or roll out GC updates gradually.</li></ul><p>While expired roots and chunk duplication increase storage costs slightly, the tradeoff is acceptable—most customer data is updated frequently, and not all data is migrated.</p><h3 id=conclusion>Conclusion</h3><p>AWS Lambda’s evolution from small ZIP files to massive 10GB container images is a masterclass in system design. By leveraging:</p><ul><li>Deterministic block generation and convergent encryption</li><li>Intelligent caching and copy-on-write overlays</li><li>A root-based, alarmed GC system</li></ul><p>AWS was able to maintain low cold start times while scaling Lambda to support modern containerized workflows. This architecture not only optimizes performance and resource usage but also preserves tenant isolation and security, all without disrupting the user experience.</p></content><p><a href=https://goyal-aman.github.io/blog/aws/>#AWS</a>
<a href=https://goyal-aman.github.io/blog/lambda/>#Lambda</a>
<a href=https://goyal-aman.github.io/blog/serverless/>#Serverless</a>
<a href=https://goyal-aman.github.io/blog/container/>#Container</a></p></main><footer><footer style="text-align:center;padding:1.5rem 0;font-size:.9rem;color:#777"><div><a href=https://github.com/goyal-aman target=_blank style="margin:0 10px;color:inherit"><i class="fab fa-github fa-lg"></i>
</a><a href=https://www.linkedin.com/in/ln-amangoyal target=_blank style="margin:0 10px;color:inherit"><i class="fab fa-linkedin fa-lg"></i>
</a><a href=https://aman-goyal.medium.com/ target=_blank style="margin:0 10px;color:inherit"><i class="fab fa-medium fa-lg"></i>
</a><a href=https://leetcode.com/sichern target=_blank style="margin:0 10px;color:inherit"><img src=/images/leetcode.svg alt=LeetCode style=height:20px;vertical-align:middle>
</a><a href=mailto:amangoyal8110@gmail.com style="margin:0 10px;color:inherit" title=Email><i class="fas fa-envelope fa-lg"></i></a></div><p>© 2025 Aman Goyal. Built with ❤️ using
<a href=https://gohugo.io target=_blank style=color:inherit;text-decoration:underline>Hugo</a>.</p></footer></footer></body></html>