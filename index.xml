<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on Aman Goyal</title><link>https://goyal-aman.github.io/</link><description>Recent content in Home on Aman Goyal</description><generator>Hugo</generator><language>en-US</language><copyright>Copyright © 2025, Aman Goyal.</copyright><lastBuildDate>Wed, 01 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://goyal-aman.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Low-Cost, Zero-Ops Analytics at Scale</title><link>https://goyal-aman.github.io/low-cost-zero-ops-analytics-at-scale/</link><pubDate>Wed, 01 Oct 2025 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/low-cost-zero-ops-analytics-at-scale/</guid><description>&lt;hr&gt;
&lt;p&gt;One of the early challenges our product teams had was visibility — not having a clear view of how users interact with our product or what their experience looks like. This made it hard for them to plan what to improve next.&lt;/p&gt;
&lt;p&gt;We’re a small, independent team within a fast-growing financial technology arm of a large enterprise exploring new initiatives. While we operate autonomously, all security standards and org-level policies still apply to us. This means we get the freedom to experiment, but the solution has to be secure and compliant from day one.&lt;/p&gt;</description></item><item><title>[One Paper Later] On-demand Container Loading in AWS Lambda</title><link>https://goyal-aman.github.io/one-paper-later-on-demand-container-loading-in-aws-lambda/</link><pubDate>Mon, 07 Apr 2025 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/one-paper-later-on-demand-container-loading-in-aws-lambda/</guid><description>&lt;hr&gt;
&lt;p&gt;You can also listen to AI generated discussion&lt;/p&gt;
&lt;iframe style="border-radius:12px" src="https://open.spotify.com/embed/episode/0IxfiKRMdnSIcDIMxChsd7?utm_source=generator" width="100%" height="152" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"&gt;&lt;/iframe&gt;
&lt;hr&gt;
&lt;h1 id="overview"&gt;Overview&lt;/h1&gt;
&lt;p&gt;AWS released this paper &lt;a href="https://www.usenix.org/system/files/atc23-brooker.pdf"&gt;On-demand Container Loading in AWS Lambda&lt;/a&gt; which discusses how they were able to scale their Lambda offering to support container images upto &lt;strong&gt;10 GiB&lt;/strong&gt; from originail &lt;strong&gt;250 Mib&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Originally, users had to ZIP their code and upload it to S3 to run on Lambda. For each new invocation (especially after a cold start), AWS would spin up a new lightweight VM, pull the ZIP file, and execute it. This worked well because AWS’s global backbone network is fast and 250 MiB is relatively small, keeping cold-start times low (typically ~50ms).&lt;/p&gt;</description></item><item><title>DocumentDB Load Balancing: A Key Learning from Our Load Testing</title><link>https://goyal-aman.github.io/documentdb-load-balancing-a-key-learning-from-our-load-testing/</link><pubDate>Wed, 26 Mar 2025 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/documentdb-load-balancing-a-key-learning-from-our-load-testing/</guid><description>&lt;hr&gt;
&lt;h1 id="tldr"&gt;TLDR;&lt;/h1&gt;
&lt;p&gt;API Gateway can provide caching, logging auth and load balancer distributes traffic between 2 or more servers for high-availability and horizontal scaling.&lt;/p&gt;
&lt;p&gt;Both load balancer and Api gateways are used between web clients and web servers. But they have served different purpose, that is to say, they are not interchangeable.&lt;/p&gt;
&lt;h1 id="load-balancers"&gt;Load Balancers&lt;/h1&gt;
&lt;p&gt;Core function of load balancer is to distribute traffic. They receive traffic from web client’s and distribute them between 2 or more web servers.&lt;/p&gt;</description></item><item><title>Distributed Locks - Naive</title><link>https://goyal-aman.github.io/distributed-locks-naive/</link><pubDate>Mon, 30 Dec 2024 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/distributed-locks-naive/</guid><description>&lt;hr&gt;
&lt;p&gt;Locks are used by processes to acquire exclusive access to resource which are shared among many processes. Exclusive access is required to prevent race conditions which hard debug and nightmare to detect.&lt;/p&gt;
&lt;p&gt;Imagine scenario of an admin is updating an email group by uploading a file. The process works like this:&lt;/p&gt;
&lt;p&gt;All existing users in the group are removed.
New users listed in the file are added in batches (e.g., 10,000 at a time).
Seems straightforward, right? But now, consider what happens if another file is uploaded while the first one is still being processed.&lt;/p&gt;</description></item><item><title>Understanding OLAP and OLTP</title><link>https://goyal-aman.github.io/understanding-olap-and-oltp/</link><pubDate>Mon, 23 Dec 2024 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/understanding-olap-and-oltp/</guid><description>&lt;hr&gt;
&lt;h1 id="tldr"&gt;TLDR;&lt;/h1&gt;
&lt;p&gt;Any database falls into one of two category OLAP or OLTP — depending on the access pattern for which it is optimised&lt;/p&gt;
&lt;h1 id="key-differences-olap-vs-oltp"&gt;Key differences: OLAP vs. OLTP&lt;/h1&gt;
&lt;p&gt;The primary purpose of online analytical processing (OLAP) is to analyse aggregated data, while the primary purpose of online transaction processing (OLTP) is to process database transactions.&lt;/p&gt;
&lt;p&gt;You use OLAP systems to generate reports, perform complex data analysis, and identify trends. In contrast, you use OLTP systems to process orders, update inventory, and manage customer accounts.&lt;/p&gt;</description></item><item><title>Understanding OLAP and OLTP</title><link>https://goyal-aman.github.io/understanding-olap-and-oltp/</link><pubDate>Mon, 23 Dec 2024 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/understanding-olap-and-oltp/</guid><description>&lt;hr&gt;
&lt;h1 id="why-relational-databases-struggle-with-long-tail-data"&gt;Why Relational Databases Struggle with Long-Tail Data&lt;/h1&gt;
&lt;p&gt;Most systems have a few popular records that get accessed all the time — and millions of others that are rarely touched. This pattern is called the &lt;strong&gt;long tail&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Popularity
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│&lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="se"&gt;&lt;/span&gt;│ &lt;span class="p"&gt;|&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│ &lt;span class="p"&gt;|&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│ &lt;span class="p"&gt;|&lt;/span&gt;____________________
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;└───────────────────────────────▶
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Head &lt;span class="o"&gt;(&lt;/span&gt;popular&lt;span class="o"&gt;)&lt;/span&gt; Tail &lt;span class="o"&gt;(&lt;/span&gt;rare&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Relational databases (like MySQL or PostgreSQL) use &lt;strong&gt;B-tree indexes&lt;/strong&gt; to find rows quickly.&lt;br&gt;
They work great when most queries hit the same small set of data — the “head.”&lt;br&gt;
But when the dataset grows huge and queries become random, indexes get so large that they no longer fit in memory.&lt;/p&gt;</description></item><item><title>Load Balancer vs. API Gateway: Understanding the Differences</title><link>https://goyal-aman.github.io/load-balancer-vs.-api-gateway-understanding-the-differences/</link><pubDate>Mon, 16 Dec 2024 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/load-balancer-vs.-api-gateway-understanding-the-differences/</guid><description>&lt;hr&gt;
&lt;h1 id="tldr"&gt;TLDR;&lt;/h1&gt;
&lt;p&gt;API Gateway can provide caching, logging auth and load balancer distributes traffic between 2 or more servers for high-availability and horizontal scaling.&lt;/p&gt;
&lt;p&gt;Both load balancer and Api gateways are used between web clients and web servers. But they have served different purpose, that is to say, they are not interchangeable.&lt;/p&gt;
&lt;h1 id="load-balancers"&gt;Load Balancers&lt;/h1&gt;
&lt;p&gt;&lt;img src="https://goyal-aman.github.io/images/load_balancer.png" alt="load-balancer"&gt;
Core function of load balancer is to distribute traffic. They receive traffic from web client’s and distribute them between 2 or more web servers.&lt;/p&gt;</description></item><item><title>Storing Values within Index</title><link>https://goyal-aman.github.io/storing-values-within-index/</link><pubDate>Mon, 09 Dec 2024 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/storing-values-within-index/</guid><description>&lt;hr&gt;
&lt;p&gt;Relational databases can have one primary index and any number of secondary indexes. When queries uses indexes they use keys in the index to find values. There are two ways to have values&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Store actual row in index&lt;/li&gt;
&lt;li&gt;Store reference to rows in index&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Storing references to rows in index is a good when there are any secondary indexes. In this way when a value needs to be updated in row, it can be updated in one place and all the indexes can refer to that one value. Also transactional guarantees are easy to implement in this case. However, challenges may arrive when size of updated row is much larger then original row size that it cannot fit in its current heap location, in which case, row need to move to new location in heap. This requires either updating references in all secondary indexes to new location or leaving a forwarding pointer behind. In normal cases, however, hopping from indexes to heap for reads is too much of performance penalty.&lt;/p&gt;</description></item><item><title>Databases: Memory and Disks</title><link>https://goyal-aman.github.io/databases-memory-and-disks/</link><pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/databases-memory-and-disks/</guid><description>&lt;hr&gt;
&lt;p&gt;Most databases rely on disks and SSD’s to store both data and data structures like table, rows, indexes. There are primarily two reasons for this: disk’s and SSD’s are persistent (or durable) that means data is not lost in case of power loss and they are much cheaper than ram for per Gb cost. Relying on persistent storage devices though comes with challenges. Data in memory needs to be encoded into certain format before it can be written on to them which is slow and CPU intensive.&lt;/p&gt;</description></item></channel></rss>