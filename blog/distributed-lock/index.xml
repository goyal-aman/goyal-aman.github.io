<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Distributed Lock on Aman Goyal</title><link>https://goyal-aman.github.io/blog/distributed-lock/</link><description>Recent content in Distributed Lock on Aman Goyal</description><generator>Hugo</generator><language>en-US</language><copyright>Copyright Â© 2025, Aman Goyal.</copyright><lastBuildDate>Mon, 30 Dec 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://goyal-aman.github.io/blog/distributed-lock/index.xml" rel="self" type="application/rss+xml"/><item><title>Distributed Locks - Naive</title><link>https://goyal-aman.github.io/distributed-locks-naive/</link><pubDate>Mon, 30 Dec 2024 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/distributed-locks-naive/</guid><description>&lt;hr&gt;
&lt;p&gt;Locks are used by processes to acquire exclusive access to resource which are shared among many processes. Exclusive access is required to prevent race conditions which hard debug and nightmare to detect.&lt;/p&gt;
&lt;p&gt;Imagine scenario of an admin is updating an email group by uploading a file. The process works like this:&lt;/p&gt;
&lt;p&gt;All existing users in the group are removed.
New users listed in the file are added in batches (e.g., 10,000 at a time).
Seems straightforward, right? But now, consider what happens if another file is uploaded while the first one is still being processed.&lt;/p&gt;</description></item></channel></rss>