<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Index on Aman Goyal</title><link>https://goyal-aman.github.io/blog/index/</link><description>Recent content in Index on Aman Goyal</description><generator>Hugo</generator><language>en-US</language><copyright>Copyright Â© 2025, Aman Goyal.</copyright><lastBuildDate>Mon, 09 Dec 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://goyal-aman.github.io/blog/index/index.xml" rel="self" type="application/rss+xml"/><item><title>Storing Values within Index</title><link>https://goyal-aman.github.io/storing-values-within-index/</link><pubDate>Mon, 09 Dec 2024 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/storing-values-within-index/</guid><description>&lt;hr>
&lt;p>Relational databases can have one primary index and any number of secondary indexes. When queries uses indexes they use keys in the index to find values. There are two ways to have values&lt;/p>
&lt;p>Store actual row in index
Store reference to rows in index
Storing references to rows in index is a good when there are any secondary indexes. In this way when a value needs to be updated in row, it can be updated in one place and all the indexes can refer to that one value. Also transactional guarantees are easy to implement in this case. However, challenges may arrive when size of updated row is much larger then original row size that it cannot fit in its current heap location, in which case, row need to move to new location in heap. This requires either updating references in all secondary indexes to new location or leaving a forwarding pointer behind. In normal cases, however, hopping from indexes to heap for reads is too much of performance penalty.&lt;/p></description></item></channel></rss>