<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on Aman Goyal</title><link>https://goyal-aman.github.io/blog/</link><description>Recent content in Blog on Aman Goyal</description><generator>Hugo</generator><language>en-US</language><copyright>Copyright © 2025, Aman Goyal.</copyright><lastBuildDate>Wed, 26 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://goyal-aman.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>DocumentDB Load Balancing: A Key Learning from Our Load Testing</title><link>https://goyal-aman.github.io/documentdb-load-balancing-a-key-learning-from-our-load-testing/</link><pubDate>Wed, 26 Mar 2025 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/documentdb-load-balancing-a-key-learning-from-our-load-testing/</guid><description>&lt;hr>
&lt;h1 id="tldr">TL;DR&lt;/h1>
&lt;p>Amazon DocumentDB load-balances traffic at the TCP connection level rather than at the request level. This can lead to unexpected resource distribution issues, particularly when scaling read replicas under high load. The solution? Restarting application pods to establish new TCP connections that are evenly distributed across replicas.&lt;/p>
&lt;h1 id="understanding-the-load-balancing-issue">Understanding the Load Balancing Issue&lt;/h1>
&lt;p>In a typical Amazon DocumentDB cluster, there is a primary node that handles all write operations and one or more read replicas to distribute read traffic. During our load testing, we observed that a single read replica was hitting over 90% CPU utilization due to high read requests.&lt;/p></description></item><item><title>Distributed Locks - Naive</title><link>https://goyal-aman.github.io/distributed-locks-naive/</link><pubDate>Mon, 30 Dec 2024 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/distributed-locks-naive/</guid><description>&lt;hr>
&lt;p>Locks are used by processes to acquire exclusive access to resource which are shared among many processes. Exclusive access is required to prevent race conditions which hard debug and nightmare to detect.&lt;/p>
&lt;p>Imagine scenario of an admin is updating an email group by uploading a file. The process works like this:&lt;/p>
&lt;p>All existing users in the group are removed.
New users listed in the file are added in batches (e.g., 10,000 at a time).
Seems straightforward, right? But now, consider what happens if another file is uploaded while the first one is still being processed.&lt;/p></description></item><item><title>Understanding OLAP and OLTP</title><link>https://goyal-aman.github.io/understanding-olap-and-oltp/</link><pubDate>Mon, 23 Dec 2024 00:00:00 +0000</pubDate><guid>https://goyal-aman.github.io/understanding-olap-and-oltp/</guid><description>&lt;hr>
&lt;h1 id="tldr">TLDR;&lt;/h1>
&lt;p>Any database falls into one of two category OLAP or OLTP — depending on the access pattern for which it is optimised&lt;/p>
&lt;h1 id="key-differences-olap-vs-oltp">Key differences: OLAP vs. OLTP&lt;/h1>
&lt;p>The primary purpose of online analytical processing (OLAP) is to analyse aggregated data, while the primary purpose of online transaction processing (OLTP) is to process database transactions.&lt;/p>
&lt;p>You use OLAP systems to generate reports, perform complex data analysis, and identify trends. In contrast, you use OLTP systems to process orders, update inventory, and manage customer accounts.&lt;/p></description></item></channel></rss>